/* This file downloaded from Highend3d.com''  ''  Highend3d.com File Information:''  ''    Script Name: Spin Faces v2.0b''    Author: knower ''    Last Updated: May 23, 2007''    Update/Change this file at:''    http://Highend3d.com/maya/downloads/mel_scripts/modeling/poly_tools/1408.html''  ''  Please do not alter any information above this line''  it is generated dynamically by Highend3d.com and will''  be changed automatically on any updates.*/////////////////////////////////////////////////////////////////////////////////////////////////////SpinFaces 2.0b////what's new:////* it's working with Maya 8.5.//* now it supports even border edges.////This mel changes the direction of the edge shared by two faces....//Lightwave users know this as SpinQuad...i wanted it for Maya...////Just select the faces or the edge you want to spin....////Giuseppe Improta//info@knower.it//http://www.knower.it////////////////////////////////////////////////////////////////////////////////////////////////////global proc SplitFace(int $SplitEdgeANum , int $SplitEdgeAVal , int $SplitEdgeBNum, int $SplitEdgeBVal, string $MergedFaceVtxs[], int $EdgeSelCheck, string $nextVtxA, string $nextVtxB){                                                                                                                                 polySplit -ep $SplitEdgeANum $SplitEdgeAVal -ep $SplitEdgeBNum $SplitEdgeBVal;select $nextVtxA;select -add $nextVtxB;$selEdge = `polyListComponentConversion -fv -te -in `;print ("Splitted edges "  + $SplitEdgeANum + " and " + $SplitEdgeBNum);print "\n";if ($EdgeSelCheck == 1)	{	select $selEdge;	}else	{		string $newFaces[] = `polyListComponentConversion -fv -tf -in $MergedFaceVtxs`;		select $newFaces;	}}global proc spinFaces(){//storing the starting components and storing if the selection comes from edgestring $selFaces[] = `ls -sl -fl`;int $EdgeSelCheck = 0;string $selEdge = "";//checking for errosstring $TypeCheck = whatComponent($selFaces[0]);//assuming the selection is the edgeif ($TypeCheck == "e")	{	$EdgeSelCheck = 1;	if (size($selFaces) > 1)		{		error "you have to select only ONE edge...";		}	}else	{		//checking if selection is face based				string $selFaces[] = `ls -sl -fl`;		string $TypeCheck = whatComponent($selFaces[0]);		if ($TypeCheck != "f")			error "You must select 2 faces !!";				//checking if selection lacks one face				if (($selFaces[0] == "")||($selFaces[2]!= "")||(size($selFaces)<2))			error "You must select 2 faces !!";				//checking if there is a shared edge				//select (`polyListComponentConversion -fe -tf`);					string $sharedEdgeCheck[] = `polyListComponentConversion -ff -te -in`;		if (size($sharedEdgeCheck)>1)			error "you have selected border faces!! please select their shared edge";				if ($sharedEdgeCheck[0] == "")			error "You must select 2 faces WITH A SHARED EDGE!!";	}		// go on by getting shared edge numberstring $SharedEdge[];string $SharedEdgeVtxs[];string $selFacesVtxs[];if ($EdgeSelCheck == 1)	{	$SharedEdge[0] = $selFaces[0];	$selFaces = `polyListComponentConversion -fe -tf`;	$SharedEdgeVtxs = unfilterComponents(`polyListComponentConversion -fe -tv $SharedEdge`);	$selFacesVtxs = unfilterComponents(`polyListComponentConversion -ff -tv $selFaces`);	}else	{	$SharedEdge = unfilterComponents(`polyListComponentConversion -ff -te -in $selFaces`);	$SharedEdgeVtxs = unfilterComponents(`polyListComponentConversion -fe -tv $SharedEdge`);	$selFacesVtxs = unfilterComponents(`polyListComponentConversion -ff -tv $selFaces`);	}	//deleting SharedEdgepolyDelEdge $SharedEdge[0];//storing resultant facestring $MergedFace[] = unfilterComponents(`polyListComponentConversion -fv -tf -in $selFacesVtxs`);string $MergedFaceBasename[];tokenize ($MergedFace[0], ".", $MergedFaceBasename);//getting the vertices of MergedFace counter-clockwiseselect $MergedFace[0];string $MergedFaceVtxAll[] = `polyInfo -fv`;string $MergedFaceVtxAllToked[];tokenize($MergedFaceVtxAll[0], " ", $MergedFaceVtxAllToked);string $MergedFaceVtxs[];int $i=2;int $j=0;for ($i=2; $i<(size($MergedFaceVtxAllToked)-1); $i++)	{	$MergedFaceVtxs[$j] = $MergedFaceBasename[0] + "." + "vtx[" + $MergedFaceVtxAllToked[$i] + "]";	$j=$j+1;	}//finding next vertex in line with the first vertex of SharedEdgeint $nextVtxAindex = matchItem($SharedEdgeVtxs[0],$MergedFaceVtxs);string $nextVtxsA;if ($nextVtxAindex+1<size($MergedFaceVtxs))$nextVtxA = $MergedFaceVtxs[$nextVtxAindex+1];else$nextVtxA = $MergedFaceVtxs[0];//finding next vertex in line with the first vertex of SharedEdgeint $nextVtxBindex = matchItem($SharedEdgeVtxs[1],$MergedFaceVtxs);string $nextVtxsB;if ($nextVtxBindex+1<size($MergedFaceVtxs))$nextVtxB = $MergedFaceVtxs[$nextVtxBindex+1];else$nextVtxB = $MergedFaceVtxs[0];	//getting SplitEdgeA and relative num from verticesstring $SplitEdgeA[] = `polyListComponentConversion -fv -te -in $SharedEdgeVtxs[0] $nextVtxA`;int $SplitEdgeANum = convert2Num($SplitEdgeA[0]);//getting SplitEdgeB and relative num from verticesstring $SplitEdgeB[] = `polyListComponentConversion -fv -te -in $SharedEdgeVtxs[1] $nextVtxB`;int $SplitEdgeBNum = convert2Num($SplitEdgeB[0]);//getting the SplitEdgeAValstring $infoVtxs[] = polyInfo("-ev", $SplitEdgeA);string $infoVtxsToked[];tokenize($infoVtxs[0], " ", $infoVtxsToked);string $infoVtxsCheck[];$infoVtxsCheck[0] = $infoVtxsToked[2];$infoVtxsCheck[1] = $infoVtxsToked[3];int $SplitEdgeAVal = matchItem(convert2Num($nextVtxA),$infoVtxsCheck);//getting the SplitEdgeBValstring $infoVtxs[] = polyInfo("-ev", $SplitEdgeB);string $infoVtxsToked[];tokenize($infoVtxs[0], " ", $infoVtxsToked);string $infoVtxsCheck[];$infoVtxsCheck[0] = $infoVtxsToked[2];$infoVtxsCheck[1] = $infoVtxsToked[3];int $SplitEdgeBVal = matchItem(convert2Num($nextVtxB),$infoVtxsCheck);SplitFace($SplitEdgeANum, $SplitEdgeAVal,$SplitEdgeBNum,$SplitEdgeBVal,$MergedFaceVtxs,$EdgeSelCheck, $nextVtxA, $nextVtxB);}//// procedures to have better life...////find the index position in which a string is found (it is supposed that the match, if exists, happen only once)global proc int matchItem (string $what , string $where[]){int $i=0;for ($i=0; $i<size($where); $i++)	{	if ($what == $where[$i])		{		return $i;		}	}return -1;}//get the component numberglobal proc int convert2Num(string $what){	string $Num[];	tokenize($what, "[]", $Num);	return int($Num[1]);}// checking components typeglobal proc string whatComponent (string $whatisthis){string $thisis[];	tokenize($whatisthis, ".[", $thisis);	return $thisis[1];	}//get the fully unfiltered components (this works only for vtxs, edges, faces, faceVtxs)global proc string[] unfilterComponents (string $filtered[]){int $mask;if (whatComponent($filtered[0])=="vtx")$mask=31;else if (whatComponent($filtered[0])=="e")$mask=32;else if (whatComponent($filtered[0])=="f")$mask=34;else if (whatComponent($filtered[0])=="vtxFace")$mask=70;string $unfiltered[] = `filterExpand -sm $mask $filtered`;return $unfiltered;}